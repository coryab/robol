%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{IN3040 Obligatory Assignment 1}
\date{Oct 01, 2022}
\release{1.0.0}
\author{Cory Balaton}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Usage}
\label{\detokenize{usage:usage}}\label{\detokenize{usage::doc}}

\section{Requirements}
\label{\detokenize{usage:requirements}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Python 3.10.X

\end{itemize}


\section{Running the tests}
\label{\detokenize{usage:running-the-tests}}
\sphinxAtStartPar
Running the tests is very simple. There are 4 test programs that can be run, so you can choose to run them individually by specifying a number 1\sphinxhyphen{}4 as the argument, or you can choose to run them all, by specifying “all” as the argument.

\sphinxAtStartPar
Here is an example of how you would run all tests:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{tests}\PYG{o}{.}\PYG{n}{py} \PYG{n+nb}{all}
\end{sphinxVerbatim}


\section{Running the interpreter}
\label{\detokenize{usage:running-the-interpreter}}
\sphinxAtStartPar
If you want to test out the interpreter as a whole, you can absolutely do that!
There are some test programs in the \sphinxstylestrong{robol\_programs} directory that have the .robol extension.

\sphinxAtStartPar
Here is an example of how to run the interpreter with a .robol file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{/}\PYG{n}{robol} \PYG{n}{robol\PYGZus{}programs}\PYG{o}{/}\PYG{n}{loopyloop}\PYG{o}{.}\PYG{n}{robol}
\end{sphinxVerbatim}

\sphinxAtStartPar
All the robol programs from the assignment are also there if you want to test them.


\chapter{Design}
\label{\detokenize{design:design}}\label{\detokenize{design::doc}}

\section{Robot}
\label{\detokenize{design:robot}}
\sphinxAtStartPar
This class contains the position, direction, bindings, and statements of the robot.

\sphinxAtStartPar
In addition, it contains something called stack. The stack is available to push values into, so that other classes may retrieve those values in the lifetime of the program.
A good example is when an ArithmeticExp interprets a NumberExp, the NumberExp pushes its value to the stack, and then ArithmeticExp pops the stack in order to retrieve that value and use it.

\sphinxAtStartPar
Instead of dividing up bindings, start and statements into separate lists, I decided to put them all into a list called Interpretables (Couldn’t come up with a better name), as this makes it easier to create the tests, and there is essentially no difference in how they are handled by the robot.


\section{References to Robot}
\label{\detokenize{design:references-to-robot}}
\sphinxAtStartPar
most of the classes in robol need a reference to the Robot instance inside the program.
The earliest prototype of the language took the robot as a parameter when creating an instance of a class that needed said reference.
This created a lot of headaches when it came to making the test programs, so I decided to take away the responsibility from the user by creating a private method in each class that contained class instances that needed references of the robot, and add it to them.
This made it a lot more user friendly, and also made it less likely to make mistakes when creating the tests.


\section{Statements}
\label{\detokenize{design:statements}}
\sphinxAtStartPar
Statements usually modify the state of the robot, whether it’s incrementing/decrementing a binding, turning the robot, or moving the robot. They behave about the same in the sense that they evaluate expressions, and then they modify the state of the robot.
Most of the classes here are built the same way, except for Loop, and Stop.
Stop just prints out the current position of the robot, but Loop is a bit more interesting.


\section{Loop}
\label{\detokenize{design:loop}}
\sphinxAtStartPar
Loop was pretty interesting to make, as you can think of it being like a small program inside the program. Although it doesn’t have its own stack and bindings, it does have its own list of statements that work pretty much the same way as the statements list of robot.
Where this design lacks a little, is that if you declare any bindings inside the loop, they will be inserted into the robot’s bindings dictionary, aka. it will be a global binding, instead of only living in the scope of the loop.

\sphinxAtStartPar
The reason I chose that Loop should have its own list of statements, is because it makes it more organized, so that you don’t need to jump back a certain amount of statements of the robot’s statements list for each iteration of the loop. This also makes nested loops possible.


\section{Expression}
\label{\detokenize{design:expression}}
\sphinxAtStartPar
All expressions work the same. They interpet the expression given, and push the result up to the stack.
NumberExp and Identifier directly push the value given to the stack, while ArithmeticExp interprets the left and right side of the equation before performing the operation. Interpreting the left and right side before performing an operation makes NumberExp naturally recursive in nature, so you can nest multiple ArithmeticExp instances inside each other.


\section{Enums}
\label{\detokenize{design:enums}}
\sphinxAtStartPar
There are parts of the code where there are comparissons, for example what binary operation is used in an arithmetic expression, and it’s natural to express the different choices with enums to make the implementations of other classes more readable.


\chapter{Interfaces}
\label{\detokenize{interfaces:module-robol_lang.interfaces}}\label{\detokenize{interfaces:interfaces}}\label{\detokenize{interfaces::doc}}\index{module@\spxentry{module}!robol\_lang.interfaces@\spxentry{robol\_lang.interfaces}}\index{robol\_lang.interfaces@\spxentry{robol\_lang.interfaces}!module@\spxentry{module}}\index{Expression (class in robol\_lang.interfaces)@\spxentry{Expression}\spxextra{class in robol\_lang.interfaces}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{interfaces:robol_lang.interfaces.Expression}}\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.interfaces.}}\sphinxbfcode{\sphinxupquote{Expression}}}
\sphinxAtStartPar
An interface for expressions.

\sphinxAtStartPar
Classes that implement the Expression interface, usually evaluate an
expression, and then push that value to the stack of a Robot instance.

\end{fulllineitems}

\index{Robol (class in robol\_lang.interfaces)@\spxentry{Robol}\spxextra{class in robol\_lang.interfaces}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{interfaces:robol_lang.interfaces.Robol}}\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.interfaces.}}\sphinxbfcode{\sphinxupquote{Robol}}}
\sphinxAtStartPar
This is the interface that most classes inherit from.

\sphinxAtStartPar
All the classes that implement neither a Statement nor an Expression,
implement Robol.

\end{fulllineitems}

\index{Statement (class in robol\_lang.interfaces)@\spxentry{Statement}\spxextra{class in robol\_lang.interfaces}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{interfaces:robol_lang.interfaces.Statement}}\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.interfaces.}}\sphinxbfcode{\sphinxupquote{Statement}}}
\sphinxAtStartPar
An interface for Statements.

\sphinxAtStartPar
Classes that implement the Statement interface, usually modify the state
of a Robot instance.

\end{fulllineitems}



\chapter{Enums}
\label{\detokenize{enums:module-robol_lang.enums}}\label{\detokenize{enums:enums}}\label{\detokenize{enums::doc}}\index{module@\spxentry{module}!robol\_lang.enums@\spxentry{robol\_lang.enums}}\index{robol\_lang.enums@\spxentry{robol\_lang.enums}!module@\spxentry{module}}\index{Assign (class in robol\_lang.enums)@\spxentry{Assign}\spxextra{class in robol\_lang.enums}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{enums:robol_lang.enums.Assign}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.enums.}}\sphinxbfcode{\sphinxupquote{Assign}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Signifies if Assignment should increment or decrement.

\end{fulllineitems}

\index{BinaryOp (class in robol\_lang.enums)@\spxentry{BinaryOp}\spxextra{class in robol\_lang.enums}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{enums:robol_lang.enums.BinaryOp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.enums.}}\sphinxbfcode{\sphinxupquote{BinaryOp}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Signifies the binary operation to be used in ArithmeticExp.

\end{fulllineitems}

\index{Direction (class in robol\_lang.enums)@\spxentry{Direction}\spxextra{class in robol\_lang.enums}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{enums:robol_lang.enums.Direction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.enums.}}\sphinxbfcode{\sphinxupquote{Direction}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Signifies the direction Turn should turn.

\end{fulllineitems}

\index{Orientation (class in robol\_lang.enums)@\spxentry{Orientation}\spxextra{class in robol\_lang.enums}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{enums:robol_lang.enums.Orientation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.enums.}}\sphinxbfcode{\sphinxupquote{Orientation}}}{\emph{\DUrole{n}{value}}}{}
\sphinxAtStartPar
Signifies the four orientations of the compass

\end{fulllineitems}



\chapter{Robol}
\label{\detokenize{robol:module-robol_lang.robol}}\label{\detokenize{robol:robol}}\label{\detokenize{robol::doc}}\index{module@\spxentry{module}!robol\_lang.robol@\spxentry{robol\_lang.robol}}\index{robol\_lang.robol@\spxentry{robol\_lang.robol}!module@\spxentry{module}}\index{Binding (class in robol\_lang.robol)@\spxentry{Binding}\spxextra{class in robol\_lang.robol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robol:robol_lang.robol.Binding}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.robol.}}\sphinxbfcode{\sphinxupquote{Binding}}}{\emph{\DUrole{n}{ident}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{expressions:robol_lang.expressions.Identifier}]{\sphinxcrossref{Identifier}}}}}, \emph{\DUrole{n}{exp}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{interfaces:robol_lang.interfaces.Expression}]{\sphinxcrossref{Expression}}}}}}{}
\sphinxAtStartPar
Class that contains an identifier and the expression to bind to it.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
ident (Identifier): The identifier of the binding

\sphinxAtStartPar
exp (Expression): The expression that will be bound to the identifier.

\end{description}
\index{interpret() (robol\_lang.robol.Binding method)@\spxentry{interpret()}\spxextra{robol\_lang.robol.Binding method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robol:robol_lang.robol.Binding.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{}
\sphinxAtStartPar
Binds a value to an identifier.

\sphinxAtStartPar
Interprets ident and exp, and inserts the expression into the bindings
dictionary of the robot with the identifier as the key.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Grid (class in robol\_lang.robol)@\spxentry{Grid}\spxextra{class in robol\_lang.robol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robol:robol_lang.robol.Grid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.robol.}}\sphinxbfcode{\sphinxupquote{Grid}}}{\emph{\DUrole{n}{east}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{interfaces:robol_lang.interfaces.Expression}]{\sphinxcrossref{Expression}}}}}, \emph{\DUrole{n}{north}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{interfaces:robol_lang.interfaces.Expression}]{\sphinxcrossref{Expression}}}}}}{}
\sphinxAtStartPar
Class that contains the dimensions of the grid.

\sphinxAtStartPar
This defines the space that the robot is allowed to travel on.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
east (Expression): How far east the grid goes.

\sphinxAtStartPar
north (Expression): How far north the grid goes.

\end{description}
\index{interpret() (robol\_lang.robol.Grid method)@\spxentry{interpret()}\spxextra{robol\_lang.robol.Grid method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robol:robol_lang.robol.Grid.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Interpret both expressions.

\sphinxAtStartPar
The result of the interpretation of the expression will be put on the
stack and the class that called this interpret method will then be
able to retrieve them by popping the stack.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Program (class in robol\_lang.robol)@\spxentry{Program}\spxextra{class in robol\_lang.robol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robol:robol_lang.robol.Program}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.robol.}}\sphinxbfcode{\sphinxupquote{Program}}}{\emph{\DUrole{n}{grid}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{robol:robol_lang.robol.Grid}]{\sphinxcrossref{robol\_lang.robol.Grid}}}}}, \emph{\DUrole{n}{robot}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{robol:robol_lang.robol.Robot}]{\sphinxcrossref{robol\_lang.robol.Robot}}}}}}{}
\sphinxAtStartPar
Class that contains all components necessary to run.

\sphinxAtStartPar
This is the starting point of a robol program, and is necessary in order
for a program to work.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
grid (Grid): The grid that the robot will move on.

\sphinxAtStartPar
robot (Robot): The robot itself.

\end{description}
\index{interpret() (robol\_lang.robol.Program method)@\spxentry{interpret()}\spxextra{robol\_lang.robol.Program method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robol:robol_lang.robol.Program.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Calls the interpret method of the robot.

\sphinxAtStartPar
Before calling the interpret method of the robot, the method adds a
reference of the program to the robot, and a reference of the robot
to the grid.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Robot (class in robol\_lang.robol)@\spxentry{Robot}\spxextra{class in robol\_lang.robol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robol:robol_lang.robol.Robot}}\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.robol.}}\sphinxbfcode{\sphinxupquote{Robot}}}
\sphinxAtStartPar
Class that interprets interpretables and moves around the grid.

\sphinxAtStartPar
This is the heart of the program. The Robot class holds almost all the
information of the program and moves on the grid according to what the
interpretables interpret.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
position (Dict): The current position of the robot.

\sphinxAtStartPar
orientation (Orientation): The current orientation of the robot.

\sphinxAtStartPar
bindings (Dict): The bindings of the robot.

\sphinxAtStartPar
interpretables (List): A list of interpretable instances.

\sphinxAtStartPar
stack (List): The robot’s stack to push and pop values.

\sphinxAtStartPar
program (Program): A reference to the program.

\end{description}
\index{interpret() (robol\_lang.robol.Robot method)@\spxentry{interpret()}\spxextra{robol\_lang.robol.Robot method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robol:robol_lang.robol.Robot.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Interprets each interpretable in interpretables.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Start (class in robol\_lang.robol)@\spxentry{Start}\spxextra{class in robol\_lang.robol}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robol:robol_lang.robol.Start}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.robol.}}\sphinxbfcode{\sphinxupquote{Start}}}{\emph{\DUrole{n}{east}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{interfaces:robol_lang.interfaces.Expression}]{\sphinxcrossref{Expression}}}}}, \emph{\DUrole{n}{north}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{interfaces:robol_lang.interfaces.Expression}]{\sphinxcrossref{Expression}}}}}}{}
\sphinxAtStartPar
Class that contains the starting point of the robot.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
east (Expression): How far east the robot should start.

\sphinxAtStartPar
north (Expression): How far north the robot should start.

\end{description}
\index{interpret() (robol\_lang.robol.Start method)@\spxentry{interpret()}\spxextra{robol\_lang.robol.Start method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{robol:robol_lang.robol.Start.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Interprets east and west.

\sphinxAtStartPar
This interprets east and west, and inserts the result into the position
dictionary of the robot.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Statements}
\label{\detokenize{statements:module-robol_lang.statements}}\label{\detokenize{statements:statements}}\label{\detokenize{statements::doc}}\index{module@\spxentry{module}!robol\_lang.statements@\spxentry{robol\_lang.statements}}\index{robol\_lang.statements@\spxentry{robol\_lang.statements}!module@\spxentry{module}}\index{Assignment (class in robol\_lang.statements)@\spxentry{Assignment}\spxextra{class in robol\_lang.statements}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{statements:robol_lang.statements.Assignment}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.statements.}}\sphinxbfcode{\sphinxupquote{Assignment}}}{\emph{\DUrole{n}{identifier}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{expressions:robol_lang.expressions.Identifier}]{\sphinxcrossref{robol\_lang.expressions.Identifier}}}}}, \emph{\DUrole{n}{assign}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{enums:robol_lang.enums.Assign}]{\sphinxcrossref{robol\_lang.enums.Assign}}}}}}{}
\sphinxAtStartPar
Class that will increment or decrement a binding by 1.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
identifier (Identifier): The identifier to increment/decrement.

\sphinxAtStartPar
assign (Assign): The enum that decides if the identifier should
increment or decrement.

\end{description}
\index{interpret() (robol\_lang.statements.Assignment method)@\spxentry{interpret()}\spxextra{robol\_lang.statements.Assignment method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{statements:robol_lang.statements.Assignment.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Interprets the identifier and increments/decrements the binding.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Loop (class in robol\_lang.statements)@\spxentry{Loop}\spxextra{class in robol\_lang.statements}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{statements:robol_lang.statements.Loop}}\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.statements.}}\sphinxbfcode{\sphinxupquote{Loop}}}
\sphinxAtStartPar
Class that will loop a set of statements until a condition is false
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
statements (Statements): The set of statements inside the loop.

\sphinxAtStartPar
condition (BoolExp): The condition for the loop to continue looping.

\end{description}
\index{interpret() (robol\_lang.statements.Loop method)@\spxentry{interpret()}\spxextra{robol\_lang.statements.Loop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{statements:robol_lang.statements.Loop.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Interprets the statements in the loop.

\sphinxAtStartPar
This interprets the statements of the loop over and over again until
the condition is false.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Step (class in robol\_lang.statements)@\spxentry{Step}\spxextra{class in robol\_lang.statements}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{statements:robol_lang.statements.Step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.statements.}}\sphinxbfcode{\sphinxupquote{Step}}}{\emph{\DUrole{n}{exp}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{interfaces:robol_lang.interfaces.Expression}]{\sphinxcrossref{Expression}}}}}}{}
\sphinxAtStartPar
Class that moves the robot a certain amount of steps.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
exp (Expression): The expression that evaluates how many steps should
be taken.

\end{description}
\index{interpret() (robol\_lang.statements.Step method)@\spxentry{interpret()}\spxextra{robol\_lang.statements.Step method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{statements:robol_lang.statements.Step.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Interprets the expression and moves the robot.

\sphinxAtStartPar
First it evaluates the expression, then it checks if the amount of
steps would put the robot out of bounds, and if it does, then it raises
an exception, otherwise it will move.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Stop (class in robol\_lang.statements)@\spxentry{Stop}\spxextra{class in robol\_lang.statements}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{statements:robol_lang.statements.Stop}}\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.statements.}}\sphinxbfcode{\sphinxupquote{Stop}}}
\sphinxAtStartPar
Class that signals that the program is done.
\index{interpret() (robol\_lang.statements.Stop method)@\spxentry{interpret()}\spxextra{robol\_lang.statements.Stop method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{statements:robol_lang.statements.Stop.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Prints out the current position of the robot.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Turn (class in robol\_lang.statements)@\spxentry{Turn}\spxextra{class in robol\_lang.statements}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{statements:robol_lang.statements.Turn}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.statements.}}\sphinxbfcode{\sphinxupquote{Turn}}}{\emph{\DUrole{n}{direction}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{enums:robol_lang.enums.Direction}]{\sphinxcrossref{robol\_lang.enums.Direction}}}}}}{}
\sphinxAtStartPar
Class that turns the robot clockwise/counterclockwise.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
direction (Direction): Which direction to turn.

\end{description}
\index{interpret() (robol\_lang.statements.Turn method)@\spxentry{interpret()}\spxextra{robol\_lang.statements.Turn method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{statements:robol_lang.statements.Turn.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Sets the new orientation of the robot.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Expressions}
\label{\detokenize{expressions:module-robol_lang.expressions}}\label{\detokenize{expressions:expressions}}\label{\detokenize{expressions::doc}}\index{module@\spxentry{module}!robol\_lang.expressions@\spxentry{robol\_lang.expressions}}\index{robol\_lang.expressions@\spxentry{robol\_lang.expressions}!module@\spxentry{module}}\index{ArithmeticExp (class in robol\_lang.expressions)@\spxentry{ArithmeticExp}\spxextra{class in robol\_lang.expressions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressions:robol_lang.expressions.ArithmeticExp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.expressions.}}\sphinxbfcode{\sphinxupquote{ArithmeticExp}}}{\emph{\DUrole{n}{op}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{enums:robol_lang.enums.BinaryOp}]{\sphinxcrossref{robol\_lang.enums.BinaryOp}}}}}, \emph{\DUrole{n}{left}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{interfaces:robol_lang.interfaces.Expression}]{\sphinxcrossref{robol\_lang.interfaces.Expression}}}}}, \emph{\DUrole{n}{right}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{interfaces:robol_lang.interfaces.Expression}]{\sphinxcrossref{robol\_lang.interfaces.Expression}}}}}}{}
\sphinxAtStartPar
Class that evaluates arithmetic expressions

\sphinxAtStartPar
From the assignment, I have interpretted that relational operators are also
part of the operators used in arithmetic expressions.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
op (BinaryOp): The binary operation of the expression.

\sphinxAtStartPar
left (Expression): The left side of the expression.

\sphinxAtStartPar
right (Expression): The right side of the expression.

\end{description}
\index{interpret() (robol\_lang.expressions.ArithmeticExp method)@\spxentry{interpret()}\spxextra{robol\_lang.expressions.ArithmeticExp method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressions:robol_lang.expressions.ArithmeticExp.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Interprets left and right and evaluates the expression.

\sphinxAtStartPar
After interpreting the left and right expression, the method matches
the binary operation and performs it with left and right.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{BoolExp (class in robol\_lang.expressions)@\spxentry{BoolExp}\spxextra{class in robol\_lang.expressions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressions:robol_lang.expressions.BoolExp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.expressions.}}\sphinxbfcode{\sphinxupquote{BoolExp}}}{\emph{\DUrole{n}{a\_exp}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{expressions:robol_lang.expressions.ArithmeticExp}]{\sphinxcrossref{robol\_lang.expressions.ArithmeticExp}}}}}}{}
\sphinxAtStartPar
Class that evaluates if an arithmetic expression is true or false.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
a\_exp (ArithmeticExp): The arithmetic expression to evaluate.

\end{description}
\index{interpret() (robol\_lang.expressions.BoolExp method)@\spxentry{interpret()}\spxextra{robol\_lang.expressions.BoolExp method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressions:robol_lang.expressions.BoolExp.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Evaluates the expression to be true or false.

\sphinxAtStartPar
If the arithmetic expression is 0, then the boolean expression is false,
otherwise, it’s true. It reminds me of how Scheme evaluates if something
is true or false.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Identifier (class in robol\_lang.expressions)@\spxentry{Identifier}\spxextra{class in robol\_lang.expressions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressions:robol_lang.expressions.Identifier}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.expressions.}}\sphinxbfcode{\sphinxupquote{Identifier}}}{\emph{\DUrole{n}{identifier}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{}
\sphinxAtStartPar
Class that represents an identifier.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
identifier (Identifier): The value of the identifier.

\end{description}
\index{interpret() (robol\_lang.expressions.Identifier method)@\spxentry{interpret()}\spxextra{robol\_lang.expressions.Identifier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressions:robol_lang.expressions.Identifier.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Appends the value to the stack of the robot.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{NumberExp (class in robol\_lang.expressions)@\spxentry{NumberExp}\spxextra{class in robol\_lang.expressions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressions:robol_lang.expressions.NumberExp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{robol\_lang.expressions.}}\sphinxbfcode{\sphinxupquote{NumberExp}}}{\emph{\DUrole{n}{val}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{}
\sphinxAtStartPar
Class that represents a number.
\begin{description}
\item[{Attributes:}] \leavevmode
\sphinxAtStartPar
val (int): The value of the number.

\end{description}
\index{interpret() (robol\_lang.expressions.NumberExp method)@\spxentry{interpret()}\spxextra{robol\_lang.expressions.NumberExp method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressions:robol_lang.expressions.NumberExp.interpret}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpret}}}{}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Appends the value to the stack of the robot.
\begin{description}
\item[{Returns:}] \leavevmode
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{r}
\item\relax\sphinxstyleindexentry{robol\_lang.enums}\sphinxstyleindexpageref{enums:\detokenize{module-robol_lang.enums}}
\item\relax\sphinxstyleindexentry{robol\_lang.expressions}\sphinxstyleindexpageref{expressions:\detokenize{module-robol_lang.expressions}}
\item\relax\sphinxstyleindexentry{robol\_lang.interfaces}\sphinxstyleindexpageref{interfaces:\detokenize{module-robol_lang.interfaces}}
\item\relax\sphinxstyleindexentry{robol\_lang.robol}\sphinxstyleindexpageref{robol:\detokenize{module-robol_lang.robol}}
\item\relax\sphinxstyleindexentry{robol\_lang.statements}\sphinxstyleindexpageref{statements:\detokenize{module-robol_lang.statements}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}